<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Babylon - Basic scene</title>
  <style>
    html, body
      {
      overflow: hidden;
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      }
    #renderCanvas
      {
      width: 100%;
      height: 100%;
      touch-action: none;
      }
  </style>
  <script src="Babylon.js-master/dist/babylon.2.4.js"></script>
  <script src="handjs-master/binhand.js"></script>
  <script src="cannon.js-master/build/cannon.js"></script> 
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <script type="text/javascript">
  // Get the canvas element from our HTML below
  var canvas = document.querySelector("#renderCanvas");
  // Load the BABYLON 3D engine
  var engine = new BABYLON.Engine(canvas, true);

  var sphere;

  var clamp = function( nb, min, max )
  {
  if( nb < min )
    return min;
  if( nb > max )
    return max;
  return nb;
  }
  
  var OnKeyDown = function( event )
  {
    switch( event.key )
    {
      // Update velocity using "zqsd" keys
      case 'z': 
        sphere.physicsImpostor.applyImpulse( new BABYLON.Vector3(-1, 0, 0), sphere.getAbsolutePosition() );
        break;
      case 's': 
        sphere.physicsImpostor.applyImpulse( new BABYLON.Vector3(1, 0, 0), sphere.getAbsolutePosition() );
        break;
      case 'd': 
        sphere.physicsImpostor.applyImpulse( new BABYLON.Vector3(0, 0, 1), sphere.getAbsolutePosition() );
        break;
      case 'q': 
        sphere.physicsImpostor.applyImpulse( new BABYLON.Vector3(0, 0, -1), sphere.getAbsolutePosition() );
        break;
        
      // Reset sphere position and velocity
      case ' ': 
        sphere.position = new BABYLON.Vector3( 0, 20, 0 );
        sphere.physicsImpostor.setLinearVelocity( new BABYLON.Vector3( 0, 0, 0 ) );
        sphere.physicsImpostor.setAngularVelocity( new BABYLON.Vector3( 0, 0, 0 ) );
        break;
    }
    
    //Clamp velocity
    speedLimit = 10;
    x_velocity = clamp( sphere.physicsImpostor.getLinearVelocity().x, -speedLimit, speedLimit );
    y_velocity = clamp( sphere.physicsImpostor.getLinearVelocity().y, -speedLimit, speedLimit );
    z_velocity = clamp( sphere.physicsImpostor.getLinearVelocity().z, -speedLimit, speedLimit );
    sphere.physicsImpostor.setLinearVelocity( new BABYLON.Vector3( x_velocity, y_velocity, z_velocity ) );
  }
      
  var createScene = function() 
  {
    var scene = new BABYLON.Scene(engine);

    // Enable physics
    var gravityVector = new BABYLON.Vector3( 0,-9.81, 0 );
    var physicsPlugin = new BABYLON.CannonJSPlugin();
    scene.enablePhysics( gravityVector, physicsPlugin );

    // Camera
    var camera = new BABYLON.ArcRotateCamera( "Camera", 0, 0.8, 100, BABYLON.Vector3.Zero(), scene );
    camera.lowerBetaLimit = 0.1;
    camera.upperBetaLimit = (Math.PI / 2) * 0.9;
    camera.lowerRadiusLimit = 30;
    camera.upperRadiusLimit = 150;
    camera.attachControl( canvas, true );

    //Sphere
    sphere = BABYLON.Mesh.CreateSphere( "sphere", 10, 10, scene );
    sphere.position.y = 20;
    
    var sphereMaterial = new BABYLON.StandardMaterial( "sphere", scene );
    sphereMaterial.diffuseTexture = new BABYLON.Texture( "data/earth.jpg", scene );
    sphere.material = sphereMaterial;
    
    sphere.physicsImpostor = new BABYLON.PhysicsImpostor( sphere,
      BABYLON.PhysicsImpostor.SphereImpostor,
      { mass: 1, restitution: 0, friction: 0.1 }, 
      scene );

    // Ground
    var ground = BABYLON.Mesh.CreateGroundFromHeightMap( "ground", 
      "data/worldHeightMap.jpg",
      200, 200, 
      250,
      0, 10,
      scene, 
      false,
      function()
      {
        ground.setPhysicsState(BABYLON.PhysicsEngine.HeightmapImpostor, { mass: 0 });
      } );

    var groundMaterial = new BABYLON.StandardMaterial( "ground", scene );
    groundMaterial.diffuseTexture = new BABYLON.Texture( "data/earth.jpg", scene );
    ground.material = groundMaterial;

    // Skybox
    var skybox = BABYLON.Mesh.CreateBox( "skyBox", 800.0, scene );
    var skyboxMaterial = new BABYLON.StandardMaterial( "skyBox", scene );
    skyboxMaterial.backFaceCulling = false;
    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture( "data/sky34", scene );
    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
    skyboxMaterial.diffuseColor = new BABYLON.Color3( 0, 0, 0 );
    skyboxMaterial.specularColor = new BABYLON.Color3( 0, 0, 0 );
    skyboxMaterial.disableLighting = true;
    skybox.material = skyboxMaterial;
    
    // Light
    var spot = new BABYLON.PointLight( "spot", new BABYLON.Vector3(0, 30, 10), scene );
    spot.diffuse = new BABYLON.Color3( 1, 1, 1 );
    spot.specular = new BABYLON.Color3( 0, 0, 0 );
    
    //Sphere to see the light's position
    var sun = BABYLON.Mesh.CreateSphere( "sun", 10, 4, scene );
    sun.material = new BABYLON.StandardMaterial( "sun", scene );
    sun.material.emissiveColor = new BABYLON.Color3( 1, 1, 0 );

    //Sun animation
    var t = 180;
    var dt = 0.01;
    var R = 100;
    scene.registerBeforeRender( 
      function()
      {
        // Update mesh position
        sun.position = spot.position;
        // Update light position
        t -= dt;
        x = R * Math.cos(t);
        y = R * Math.sin(t);
        spot.position = new BABYLON.Vector3( x, y, 0 );
        
        // Decrease light intensity when sun is set to avoid shadows on the sphere
        if( spot.position.y < 0 )
          {
          spot.intensity -= 0.05*Math.cos(t) ;
          t -= 5*dt;
          }
        else
          {
          spot.intensity = 1;
          }
      } );
    

    return scene;
  }
      
  document.onkeydown = OnKeyDown;
      
  // Now, call the createScene function that you just finished creating
  var scene = createScene();
  console.log(sphere);
  // Register a render loop to repeatedly render the scene
  engine.runRenderLoop( function(){ scene.render(); } );
  // Watch for browser/canvas resize events
  window.addEventListener( "resize", function(){ engine.resize(); } );
  </script>
</body>
</html>